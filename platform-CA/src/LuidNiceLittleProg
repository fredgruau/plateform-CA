//copie d'une ancienne version de dedag qui pourrait etre utile pour consultation. 
  /*def deDag2[U](nUser: HashMap[AST[_], Int], repr: HashMap[AST[_], AST[_]], d: AST[U]): AST[U] = {
    def deDag[U](d: AST[U]): AST[U] =
      if (nUser.contains(d) && nUser(d) > 1)
         Read[U](repr(d).name)(d.mym.asInstanceOf[repr[U]]) //faut chercher le nom dans la représentation.
      else {
        val newD = d match {
          case Delayed(arg)         => deDag(arg())
          case e: EmptyBag[_]       => e  
    
          case e @ Binop(op, a, a2) => e.copy(arg = deDag(a).asInstanceOf[ ASTg2bis], arg2 = deDag(a2).asInstanceOf[ ASTg2bis])(e.l  , e.r ) //TODO we can put all the other without test of instanceof
          case e @ Binop2(o , a, a2) => e.copy(arg = deDag(a).asInstanceOf[ ASTg2bis], arg2 = deDag(a2).asInstanceOf[ ASTg2bis] )(e.l.asInstanceOf[repr[Locus]], e.r.asInstanceOf[repr[Ring]]) //Binop(op, deDag(arg), deDag(arg2))(d.l, d.r)
          case e @ Multop(op, a)    => e.copy(args = a.map(arg => deDag(arg)).asInstanceOf[Seq[ASTg2bis]])(e.l.asInstanceOf[repr[Locus]], e.r.asInstanceOf[repr[Ring]])
         case e @ Unop2(op, a)      => e.copy(arg = deDag(a).asInstanceOf[ ASTg2bis])(e.l.asInstanceOf[repr[Locus]], e.r.asInstanceOf[repr[Ring]]) //      => Unop(op, deDag(arg))(d.l, d.r)
           case e @ Unop(op, a)      => e.copy(arg = deDag(a).asInstanceOf[ ASTg2bis])(e.l.asInstanceOf[repr[Locus]], e.r.asInstanceOf[repr[Ring]]) //      => Unop(op, deDag(arg))(d.l, d.r)
          case e @ Unop2(op, a)      => e.copy(arg = deDag(a).asInstanceOf[ ASTg2bis])(e.l.asInstanceOf[repr[Locus]], e.r.asInstanceOf[repr[Ring]]) //      => Unop(op, deDag(arg))(d.l, d.r)
          case e @ Redop(op, a)     => e.copy(arg = deDag(a).asInstanceOf[ AST2[T[S,S],Ring]])(e.l.asInstanceOf[repr[S]], e.r.asInstanceOf[repr[Ring]]) //case Redop(op, arg)       => deDagRed(d.asInstanceOf[redAST]).asInstanceOf[AST2[L, R]]
           case e @ Redop2(op, a)     => e.copy(arg = deDag(a).asInstanceOf[AST2[T[S,S],Ring]])(e.l.asInstanceOf[repr[T[S,S]]], e.r.asInstanceOf[repr[Ring]]) //case Redop(op, arg)       => deDagRed(d.asInstanceOf[redAST]).asInstanceOf[AST2[L, R]]
          case e @ Broadcast(a)     => e.copy(arg = deDag(a).asInstanceOf[ AST2[S,Ring]])(e.l.asInstanceOf[repr[T[S,S]]], e.r.asInstanceOf[repr[Ring]]) // case Broadcast(arg)       => deDagBroadcast(d.asInstanceOf[broadcastAST]).asInstanceOf[ASTL[L, R]]
          case e @ Transfer(a)      => e.copy(arg = deDag(a).asInstanceOf[ AST2[T[S,S],Ring]])(e.l.asInstanceOf[repr[T[S,S]]], e.r.asInstanceOf[repr[Ring]]) //deDagTransfer(d.asInstanceOf[transferAST]).asInstanceOf[ASTL[L, R]]
          // ToDo case Sym(arg) =>  Sym(deDag(arg))(d.m2)

        }
        newD.setName(d.name)
        newD.asInstanceOf[AST[U]]
      }
    return deDag(d)
  }
   */
  
  
  


type redAST = Redop[_ <: S, _ <: S, _ <: Ring]
  type red2AST = Redop2[_ <: S, _ <: S, _ <: S, _ <: Ring]
  type broadcastAST = Broadcast[_ <: S, _ <: S, _ <: Ring]
  type transferAST = Transfer[_ <: S, _ <: S, _ <: Ring]

  
/*  def deDagRed2[S1 <: S, S2 <: S, S2new <: S, R <: Ring](a: Redop2[S1, S2, S2new, R]) = redOp2(deDag(a.arg), a.op, a.l, a.r);
    def deDagBroadcast[S1 <: S, S2 <: S, R <: Ring](a: Broadcast[S1, S2, R]) = broadcast(deDag(a.arg), a.l, a.r);
    def deDagTransfer[S1 <: S, S2 <: S, R <: Ring](a: Transfer[S1, S2, R]) = transfer(deDag(a.arg))(a.l, a.r);*/



MEMOIZING FUNCTIONS
https://medium.com/musings-on-functional-programming/scala-optimizing-expensive-functions-with-memoization-c05b781ae826

**************************************
Ce programme montre qu'on peut appeller les constructeurs de fields sous forme de methode, ce qui permet 
de ne pas utiliser de parentheses, et qui est bien car il y en a beaucoup des parentheses.

import scala.language.implicitConversions

class Ast[L,R]

class AstInt[L](a : Ast[L,Int]) {
  def f() = 1//add(a,a)
  def g() = 2//add(a,a)
}

class AstV[R](a : Ast[Vector[Boolean],R]) {
  def h() = 3
  def i() = 4
}

implicit def canonicL[L](a : Ast[L,Int]) : AstInt[L] = new AstInt(a)
implicit def canonicR[R](a : Ast[Vector[Boolean],R]) : AstV[R] = new AstV(a)

val a = new Ast[Vector[Boolean],Int]
a.f()
a.h()

************************************************************************************
Ce programme montre comment présenter une interface a l'utilisateur,
et ensuite implementer cet interface avec le compilateur (avec un arbre abstrait chargé)

import scala.language.higherKinds

abstract class Locus
abstract class V extends Locus

abstract class Ring
abstract class B extends Ring

trait Language {
  type Layer[L <: Locus, R <: Ring]
  type Field[L <: Locus, R <: Ring]

  def const[L <: Locus](b : Boolean) : Field[L,B]
  def and[L <: Locus](arg1 : Field[L,B], arg2 : Field[L,B]) : Field[L,B]
  def or[L <: Locus](arg1 : Field[L,B], arg2 : Field[L,B]) : Field[L,B]
  def not[L <: Locus](arg1 : Field[L,B]) : Field[L,B]
}

trait LanguageStdlib extends Language {
  def xor[L <: Locus](arg1 : Field[L,B], arg2 : Field[L,B]) = or( and( arg1, !arg2), and( !arg1, arg2))
}

abstract class Program extends LanguageStdlib {
  val t = const[V](true)
  val f = const[V](false)
  val d = and(t,f)
  def getT = t
}

trait LanguageImpl extends Language {
  case class FieldImpl[L <: Locus, R <: Ring](b : Boolean)

  type Layer[L <: Locus, R <: Ring] = FieldImpl[L,R]
  type Field[L <: Locus, R <: Ring] = FieldImpl[L,R]

  def const[L <: Locus](b : Boolean) = FieldImpl[L,B](b)
  def and[L <: Locus](arg1 : Field[L,B], arg2 : Field[L,B]) = FieldImpl[L,B](arg1.b & arg2.b)
  def or[L <: Locus](arg1 : Field[L,B], arg2 : Field[L,B]) = FieldImpl[L,B](arg1.b | arg2.b)
  def not[L <: Locus](arg1 : Field[L,B]) : Field[L,B] = FieldImpl[L,B](! arg1.b)
}

val p = new Program with LanguageImpl;
p.t
p.f
p.d


*******************************************************************************
Ce programme montre comment je peut implementer neg sans parentheses
import scala.language.implicitConversions

class R (val x : Int, val y :Int);

class EnrichedR (r : R) {
  def unary_! = r.x;
}
object EnrichedR {
  implicit def enrichR (r : R) = new EnrichedR(r);
}


class Test extends App {
   val r = new R(3,5);
   println( ! (new EnrichedR(r)))
}

